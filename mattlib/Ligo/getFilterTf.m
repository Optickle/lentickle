% Generic filter bank transfer function
%
% plog should contain GAIN, LIMIT, SW1R, and SW2R, read from a
%  conlog file.  SW1R and SW2R are bit masks:
%    SW1R bits - 3 = input, 4 = offset, 5:6 fm1, 7:8 fm2, ..., 15:16 fm6
%    SW2R bits - 1:2 fm7, ..., 7:8 fm10, 9 = limit, 10 = output
%  The first bit for each filter module is the "user on" bit, the
%  second is the "really on" bit.  (Note that the bit indices above
%  start at 1, not 0 as normal).
%
% pfilt should contain an array of filter module structs,
%  generated by readFilterFile, each of which contains
%  fields name and soscoef.
%
% If a filter name is give, the filter's contents are printed.
%
% h = getFilterTf(f, plog, pfilt, [name])

function h = getFilterTf(f, plog, pfilt, varargin)

  % determine output destination
  if( isempty(varargin) )
    name = [];
  else
    name = varargin{1};
  end
  if( isempty(name) )
    fid = 0;
  else
    fid = 1;
  end

  % determine filter TF
  fprintf(fid, '%4s -', name);

  % S-domain stuff
  fs = pfilt(1).fs;		% sample frequency
  digw = (2 * pi / fs) .* f;	% Convert from Hz to rad/sample
  s = exp(-i * digw);		% S for this calculation 
  ss = s .* s;			% S^2

  sw1 = plog.SW1R;
  sw2 = plog.SW2R;

  if( ~bitget(sw1, 3) | ~bitget(sw2, 10) )
    fprintf(fid, ' Off');
    h = zeros(size(f));
  else
    h = plog.GAIN * ones(size(f));
    for n = 1:length(pfilt)
      sc = pfilt(n).soscoef;
      if( (n <= 6 & bitget(sw1, 2 * n +  4)) | ...
          (n >= 7 & bitget(sw2, 2 * n - 12)) )
        for m = 1:size(sc, 1)
          num = sc(m, 1) + sc(m, 2) .* s + sc(m, 3) .* ss;
          den = sc(m, 4) + sc(m, 5) .* s + sc(m, 6) .* ss;
          h = h .* num ./ den;
        end
        fprintf(fid, ' (%d) %s', n, pfilt(n).name);
      end
    end
  end
  fprintf(fid, '\n');
